## Fixes to Looker's SDK
#### [Looker's python_SDK](https://discourse.looker.com/t/generating-client-sdks-for-the-looker-api/3185) is generated by [swagger](https://swagger.io/), which generates an up to date set of API classes and functions based on a JSON file that you can get from your Looker instance. However, there are a number of problems with the SDK that can be hard to troubleshoot. Here is a quick guide of the most common problems.


### 1. Fix a known problem with dynamic fields in the Query class
**The Problem**
* If you make a call that returns a Query() object, such as `query_api.query()` or `dashboard_api.dashboard_dashboard_elements()` you may need to manipulate the response object in order to pass it to another API call. For example, you may wish to download all of the data from a dashboard with a set of custom filters applied. The procedure for this is:
    * Get dashboard elements and iterate through them
    * For each one, grab the element.query component, remove the client_id or set it to `None`, update the filters and pass it to the `run_inline_query` call
* Query() objects have a known issue with dynamic fields (table calculations) where the JSON object is converted into a list of strings:
  * instead of `[{"table_calculation":"field_name","label":"Label"...]}`
  * You would see `['[', '{', '"', 't', 'a', 'b', 'l', 'e', '_', 'c', 'a', 'l', 'c', 'u', 'l', 'a', 't', 'i', 'o', 'n', '"', ':', ..., ']'`

**The fix**
* To convert this list of strings back to a dictionary / JSON:
  * First concatenate all of the strings: `new_string = ''.join([s for s in list_of_strings])`
  * Then parse it into json using `json.loads(new_string)`
  * _**Note** that this won't work on `NoneType` objects, so only apply this if_ `dynamic_fields is not None`
* Alternatively, apply this code directly to the query model in the generated SDK:
    * _**Note** there is a chance this may cause unexpected behaviour elsewhere in the SDK_
     _**Note** changes made to the SDK will be overwritten next time you regenerate the swagger code_
    * Go to `python_sdk/looker/models/query.py` and change `self.swagger_types` so that `'dynamic_fields': 'object'` in line 59

### 2. Fix a known problem with vis_config in the Query class
**The Problem**
* Also a problem with the Query() object. There is a known issue with the vis config being interpreted as strings instead of valid JSON:
  * instead of `[{"some_key":True, "other_key": ["list", "items"]}`
  * You would see `[{"some_key":"True", "other_key": "['list', 'items']"}`
  * "True" or a "[list]" in quotes will not be interpreted correctly by python

**The fix**
* Again, the simplest way to fix this is to edit the SDK itself:
  * Go to `python_sdk/looker/models/query.py` and change `self.swagger_types` so that `'vis_config': 'object'` in line 55
* Alternatively, if you don't want to change the SDK, we can manually change our own code:
    * We need to iterate through the vis config object and tell python to convert all of the strings to objects
    * The fastest way to do this is to tell python to literally evaluate the strings, converting them to objects
    * _**Note**_ `eval` can be dangerous and should only be used on code you know is not malicious. You can also use `from ast import literal_eval` which is safer__

```
for k, v in vis_config_object.items():
    if len(v) > 0 and (v[0] in ['[', '{'] or v in ['True', 'False'] or str.isdigit(v)):
        v = eval(v)
```

### 3. Allow requests without verifying SSL certificates (e.g. making API calls to a locally-hosted version of looker for testing)
_**IMPORTANT!** This poses a security risk. Only use this if you are making calls to a local looker server that you manage yourself and trust_
* Go to `python_sdk/looker/configuration.py` and change line 93  from `self.verify_ssl = True` to `self.verify_ssl = False`
